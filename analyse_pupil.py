"""
analyse_pupil2.py

This module analyses pupil, run and ROI data generated by the AIBS experiments 
for the Credit Assignment Project.

Authors: Jay Pina and Colleen Gillon

Date: July, 2019

Note: this code uses python 3.7.

"""

import time

import numpy as np
from matplotlib import pyplot as plt

from util import plot_util
from sess_util import sess_plot_util
from analysis import session


#############################################
def peristimulus_behavior(sess, stimtype='bricks', eyesec=3.5, runsec=3.5, 
                          phtsec=3.5, datatype='diff', first_surp=True, 
                          trans_all=False):
    """
    Returns average differences in pupil, ROI and run data, locked to surprise
    onset.
    """

    stim = sess.get_stim(stimtype)

    if first_surp:
        surp_segs = stim.get_segs_by_criteria(surp=1, remconsec=True, by='seg')
    else:
        surp_segs = stim.get_segs_by_criteria(gabfr=0, surp=1, remconsec=False, 
                                              by='seg')
    if stimtype == 'gabors':
        # get the D/E frames instead of A
        surp_segs = [seg + 3 for seg in surp_segs]
    
    surp_twopfr = stim.get_twop_fr_by_seg(surp_segs, first=True)
    surp_stimfr = stim.get_stim_fr_by_seg(surp_segs, first=True)
    
    # delay of ~0.1s to display on screen
    delay = int(np.round(sess.twop_fps * 0.1))
    surp_pupfr = sess.twop2pupfr[list(surp_twopfr)] + delay
    
    # retain only ROIs with transients during the stimulus
    if trans_all:
        transient_rois = sess.get_active_rois(fluor='dff', stimtype=None, 
                                            remnans=True)
    else:
        transient_rois = sess.get_active_rois(fluor='dff', stimtype=stimtype, 
                                            remnans=True)
   
    # get data
    roi_data = stim.get_roi_trace_array(surp_twopfr, phtsec, phtsec, 
                                        fluor='dff', integ=False, remnans=True)[1]
    # trial x fr x ROI
    roi_data = np.transpose(roi_data[np.asarray(transient_rois)], [1, 2, 0]) 
    print('{}/{} ROIs'.format(len(transient_rois), roi_data.shape[-1]))

    # these frame nbrs are off by 4 from Jay's calculation
    run_data = stim.get_run_array(surp_stimfr, runsec, runsec, 
                                  remnans=True)[1] # trial x fr

    pup_data = stim.get_pup_diam_array(surp_pupfr, eyesec, eyesec, 
                                       remnans=True)[1] # trial x fr
    datasets = [roi_data, run_data, pup_data]

    if datatype in ['diff', 'both']:
        # get avg for first and second halves
        datasets = [roi_data, run_data, pup_data]
        diffs = []
        for d in range(len(datasets)):
            n_fr = datasets[d].shape[1]
            pre  = np.nanmean(datasets[d][:, 0:int(np.floor(n_fr/2))], axis=1)
            post = np.nanmean(datasets[d][:, int(np.ceil(n_fr/2)):], axis=1)
            diffs.append(post - pre)

    if datatype == 'diff':
        return diffs
    elif datatype == 'data':
        return datasets
    elif datatype == 'both':
        return datasets, diffs


#############################################
def pup_2p_plots(diffs, sess, stimtype='bricks', eyesec=3.5, runsec=3.5, 
                     phtsec=3.5):


    print('Plotting pupil vs ROI changes\n')
    # trial [x ROI]
    [roi_diff, run_diff, pup_diff] = diffs

    roi_diff = np.nanmean(roi_diff, axis=1)

    roi_norm = roi_diff/np.max(np.absolute(roi_diff))    
    pup_norm = pup_diff/np.max(np.absolute(pup_diff))
    corr = np.corrcoef(roi_diff, pup_diff)[0, 1]

    plot_util.linclab_plt_defaults()
    delta = '\u0394'
    fig, ax = plt.subplots(nrows=2, figsize=[15, 15])
    fig.suptitle(('Mouse {}, {} {}, sess {}, {}\nRelationship between '
                  'pupil diam and dF/F changes in response to '
                  'surprise').format(sess.mouse_n, sess.line, sess.layer, 
                                      sess.sess_n, stimtype))
    ax[0].plot(pup_diff, roi_diff, marker='o', linestyle='None', 
               label='Corr = {:.2f}'.format(corr))
    ax[0].set_xlabel(u'{} pupil diam (av over {} sec)'.format(delta, eyesec))
    ax[0].set_ylabel(u'{} dF/F (av {} sec)'.format(delta, phtsec))
    ax[0].legend()

    ax[1].plot(pup_norm, label=(u'{} pupil diam ({} sec)'.format(delta, eyesec)), 
               marker='.')
    ax[1].plot(roi_norm, label=(u'{} dF/F ({} sec)'.format(delta, phtsec)), 
               marker='.')
    ax[1].set_xlabel('Surprise occurrence')
    ax[1].set_ylabel(u'{} response locked\nto surprise '
                      '(scaled)'.format(delta))
    ax[1].legend()

    fig.savefig('results/latest/m{}_s{}_{}_corr_{}.svg'.format(sess.mouse_n, 
                                            sess.sess_n, sess.layer, stimtype))


#############################################
def pup_2p_ROI_plots(gab_diffs, bri_diffs, sess, stimtype='bricks', eyesec=3.5, 
                 runsec=3.5, phtsec=3.5):

    # trial [x ROI]
    [gab_roi_diff, gab_run_diff, gab_pup_diff] = gab_diffs
    [bri_roi_diff, bri_run_diff, bri_pup_diff] = bri_diffs

    n_rois = gab_roi_diff.shape[1]
    if bri_roi_diff.shape[1] != n_rois:
        raise ValueError('Differing number of ROIs!')

    print('Getting ROI correlations\n')
    gab_corrs = []
    bri_corrs = []
    # correlate pupil diam change with ROI change for each stimulus
    for r in range(n_rois):
        gab_corrs.append(np.corrcoef(gab_roi_diff[:, r], gab_pup_diff)[0, 1])
        bri_corrs.append(np.corrcoef(bri_roi_diff[:, r], bri_pup_diff)[0, 1])

    overall_corr = np.corrcoef(gab_corrs, bri_corrs)[0, 1]

    plot_util.linclab_plt_defaults()
    fig, ax = plt.subplots(figsize=[15, 15])
    fig.suptitle(('Mouse {}, {} {}, sess {}, {}\nRelationship between the '
                  'correlation btw pupil diam and dF/F changes to surprise\n'
                  'for gabors vs bricks for each ROI').format(sess.mouse_n, 
                                sess.line, sess.layer, sess.sess_n, stimtype))
    ax.plot(gab_corrs, bri_corrs, marker='o', linestyle='None', 
            label='Corr = {:.2f}'.format(overall_corr))
    ax.legend()
    ax.set_xlabel('Gabors correlation')
    ax.set_ylabel('Bricks correlation')

    fig.savefig('results/latest/m{}_s{}_{}_ROIcorrs.svg'.format(sess.mouse_n, 
                                                    sess.sess_n, sess.layer))


#############################################
def scale_sort_trace_data(tr_data, fig_type='byplot', dils=['dil', 'undil']):
    """
    scale_sort_trace_data(tr_data)

    Returns a dictionary ROI traces scaled and sorted as specified.

    Required args:        
        - tr_data (dict): dictionary containing information to plot colormap.
            ['n_seqs'] (list)    : ordered list of number of segs for each
                                   dilation value
            ['roi_me'] (dict)    : ordered list of trace mean/medians
                                   for each ROI as 2D arrays or nested lists, 
                                   structured as:
                                       ROIs x frames, 
                                   (NaN arrays for combinations with 0 seqs.)

    Optional args:
        - fig_type (str) : how to scale and sort ROIs, 
                           i.e. each plot separately ('byplot'), or by a
                                dilation ('byundil', 'bydil')
                           default: 'byplot'
        - dils (list)    : dilation value names used in keys, ordered
                           default: ['undil', 'dil']
    
    Returns:
        - scaled_sort_data_me (list): list sorted by dils of 2D arrays, 
                                      structured as: ROIs x frames
    """

    sorted_data = []

    scale_vals = []
    sort_args = []
    for data in tr_data['roi_me']:
        min_vals = np.nanmin(data, axis=1).tolist()
        max_vals = np.nanmax(data, axis=1).tolist()
        scale_vals.append([min_vals, max_vals])
        sort_args.append(np.argsort(np.argmax(data, axis=1)).tolist()) # sort order

    for d, dil in enumerate(dils):
        me = np.asarray(tr_data['roi_me'][d])
        if tr_data['n_seqs'][d] == 0:
            min_v, max_v = np.asarray(scale_vals[1-d])
            sort_arg = sort_args[1-d]
        elif fig_type == 'byplot':
            min_v, max_v = np.asarray(scale_vals[d])
            sort_arg = sort_args[d]
        else:
            min_v = np.nanmin(np.asarray([vals[0] for vals in scale_vals]), axis=0)
            max_v = np.nanmax(np.asarray([vals[1] for vals in scale_vals]), axis=0)
            if fig_type == 'by{}'.format(dil):
                sort_arg = sort_args[d]
            elif fig_type == 'by{}'.format(dils[1-d]):
                sort_arg = sort_args[1-d]

        me_scaled = ((me.T - min_v)/(max_v - min_v))[:, sort_arg]
        sorted_data.append(me_scaled)                
    
    return sorted_data


#############################################
def split_2p_colorplots(data, sess, stimtype='bricks', eyesec=3.5, runsec=3.5, 
                        phtsec=3.5):

    # trial x fr [x ROI]
    [roi_data, run_data, pup_data] = data

    if stimtype == 'bricks':
        start = 1/4
    else:
        start = 1/2
    pre = (1 - 2*start) * phtsec

    # I actually just want the second half of the data
    roi_data = roi_data[:, int(np.round(len(roi_data)*start)):]
    run_data = run_data[:, int(np.round(len(run_data)*start)):]
    pup_data = pup_data[:, int(np.round(len(pup_data)*start)):]

    pup_overall_mean = np.nanmean(pup_data)
    pup_trial_means = np.nanmean(pup_data, axis=-1) 
    # pup_trial_mean = np.nanmean(pup_trial_means, axis=-1) # altern. threshold

    dilated_trials = np.where(pup_trial_means > pup_overall_mean)[0].tolist()
    undilated_trials = list(set(range(len(pup_data))) - set(dilated_trials))

    dil_roi_data = np.nanmean(roi_data[dilated_trials], axis=0).T
    undil_roi_data = np.nanmean(roi_data[undilated_trials], axis=0).T

    if len(dilated_trials) == 0:
        dil_roi_data = np.full_like(undil_roi_data, np.nan, dtype=np.double)
    elif len(undilated_trials) == 0:
        undil_roi_data = np.full_like(dil_roi_data, np.nan, dtype=np.double)

    tr_data = {'roi_me': [dil_roi_data, undil_roi_data],
               'n_seqs': [len(dilated_trials), len(undilated_trials)]}

    cmap = plot_util.manage_mpl(cmap=True, nbins=100)

    gentitle = (('Mouse {}, {} {}, sess {}, {}\nSurprise responses during '
                 'high vs low pupil dilation').format(sess.mouse_n, sess.line, 
                  sess.layer, sess.sess_n, stimtype))
    dils = ['dil', 'undil']
    nrois = roi_data.shape[-1]
    yticks_ev = int(10 * np.max([1, np.ceil(nrois/100)])) # to avoid more than 10 ticks
    print('Plotting colormaps\n')
    for fig_type in ['byplot', 'bydil', 'byundil']:
        tr_data['sorted_data'] = scale_sort_trace_data(tr_data, 
                                      fig_type=fig_type, dils=dils)    

        if fig_type in ['bydil', 'byundil']:
            peak_sort = ' across plots'
            scale_type = ' by {}ated data'.format(fig_type[2:])
            sharey = True
        else:
            peak_sort = ''
            scale_type = ' within plot'
            sharey = False

        subtitle = ('ROIs sorted by peak activity{} and '
                    'scaled{}').format(peak_sort, scale_type)
        fig, ax = plt.subplots(ncols=2, figsize=[30, 15], sharey=sharey)
        
        for d, dil in enumerate(dils):    
            sub_ax = ax[d]
            title = u'{}ated seqs (n={})'.format(dil.capitalize(), 
                                                 tr_data['n_seqs'][d])

            sess_plot_util.add_axislabels(sub_ax, fluor='dff', 
                                          y_ax='ROIs', datatype='roi')
            im = plot_util.plot_colormap(sub_ax, tr_data['sorted_data'][d], 
                                    title=title, cmap=cmap, 
                                    yticks_ev=yticks_ev,
                                    xran=[-pre, phtsec])
            if stimtype == 'bricks':
                plot_util.add_bars(sub_ax, 0)
        if stimtype == 'gabors':
            sess_plot_util.plot_labels(ax, gabfr=3, plot_vals='surp', 
                            pre=pre, post=phtsec, sharey=sharey, 
                            t_heis=-0.02)

        plot_util.add_colorbar(fig, im, len(dils))
        fig.suptitle('{}\n{}'.format(gentitle, subtitle))
        fig.savefig('results/latest/m{}_s{}_{}_cm_{}_{}.png'.format(sess.mouse_n, 
                                   sess.sess_n, sess.layer, stimtype, fig_type))
        plt.close(fig)


#############################################
def quick_run(sessid, stimtype='bricks', runtype='prod', eyesec=3.5, runsec=2, 
              phtsec=3.5):

    sess = session.Session('../data/AIBS', sessid=sessid, runtype=runtype)
    sess.extract_sess_attribs()
    sess.extract_info()

    try:
        sess._load_pup_data()
    except OSError as err:
        print(err)
        return

    # diffs = peristimulus_behavior(sess, stimtype=stimtype, 
    #                               eyesec=eyesec, runsec=runsec, 
    #                               phtsec=phtsec, datatype='diff', 
    #                               first_surp=True)

    # pup_2p_plots(diffs, sess, stimtype, eyesec, runsec, phtsec)


    # if stimtype == 'gabors': # to avoid doing it twice
    #     gab_diffs = peristimulus_behavior(sess, stimtype='gabors', 
    #                                   eyesec=eyesec, runsec=runsec, 
    #                                   phtsec=phtsec, datatype='diff', 
    #                                   first_surp=True, trans_all=True)
    #     bri_diffs = peristimulus_behavior(sess, stimtype='bricks', 
    #                                   eyesec=eyesec, runsec=runsec, 
    #                                   phtsec=phtsec, datatype='diff', 
    #                                   first_surp=True, trans_all=True)

    #     pup_2p_ROI_plots(gab_diffs, bri_diffs, sess, stimtype, eyesec, runsec, 
    #                      phtsec)

    first_surp = True
    eyesec, runsec, phtsec = [4, 4, 4]
    if stimtype == 'gabors':
        first_surp = True # also did False
        eyesec, runsec, phtsec = [1.5, 1.5, 1.5]

    data = peristimulus_behavior(sess, stimtype=stimtype, 
                                 eyesec=eyesec, runsec=runsec, 
                                 phtsec=phtsec, datatype='data', 
                                 first_surp=first_surp)

    split_2p_colorplots(data, sess, stimtype, eyesec, runsec, phtsec)

