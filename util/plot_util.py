'''
plot_util.py

This module contains basic functions for plotting with pyplot for data 
generated by the AIBS experiments for the Credit Assignment Project

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 2.7.

'''
import os

import numpy as np
from matplotlib import pyplot as plt

import gen_util, str_util


#############################################
def plot_seg_comp(analys_par, plot_vals='diff', op='diff'):
    """
    plot_seg_comp(analys_par)

    Creates lists with different components needed when plotting segments, 
    namely positions of labels, ordered labels, positions of heavy bars and 
    position of regular bars.

    Arguments:
        - analys_par (dict): dictionary containing relevant parameters
                             to what order the gabor frames will be plotted in
                ['gab_fr'] (int or list): gabor frame values to include
                                         (e.g., 0, 1, 2, 3)
                ['pre'] (float)         : range of frames to include before each 
                                          frame reference (in s)
                ['post'] (float)        : range of frames to include after each 
                                          frame reference (in s)

    Optional arguments:
        - plot_vals (str): 'surp', 'nosurp' or 'diff'
                           default: 'diff'
        - op (str)       : 'surp', 'nosurp' or 'diff'
                           default: 'diff'
    
    Returns:
        - xpos (list)          : list of x coordinates at which to add labels
                                 (same length as labels)
        - labels (list)         : ordered list of labels for gabor frames
        - hbars (list or float): list of x coordinates at which to add 
                                 heavy dashed vertical bars
                                 default: None
        - bars (list or float) : list of x coordinates at which to add 
                                 dashed vertical bars
                                 default: None
    """
    if analys_par['pre'] == 0 and analys_par['post'] == 1.5:
        xpos = [0.15, 0.45, 0.75, 1.05, 1.35]
        labels = plot_val_lab(plot_vals, op, analys_par['gab_fr'])
        bars = [0.3, 0.6, 0.9, 1.2]
        if analys_par['gab_fr'] == 3:
            hbars=None
        else:
            hbars = np.round(1.2 - 0.3*(analys_par['gab_fr']+1), 1)
            bars = gen_util.remove_if(bars, hbars)

    else:
        raise NotImplementedError('Figure parameters for x values and seg bars '
                                  'having only been implemented for pre=0, '
                                  'post=1.5.')
    return xpos, labels, hbars, bars


#############################################
def plot_val_lab(plot_vals='diff', op='diff', start_fr=-1):
    """
    plot_val_lab()

    Creates a list of labels for gabor frames based on values that are plotted,
    and operation on surprise v no surprise, starting with gray.

    Optional arguments:
        - plot_vals (str): 'surp', 'nosurp', 'reg' or 'diff'
                           default: 'diff'
        - op (str)       : 'surp', 'nosurp', 'reg' or 'diff'
                           default: 'diff'
        - start_fr (int) : starting gabor frame 
                           (-1: gray, 0: A, 1: B, 2:C, 3:D/E)
                           default: -1
    
    Returns:
        - labels (list)  : list of labels for gabor frames
    """
    labels = ['gray', 'A', 'B', 'C']

    if plot_vals == 'surp':
        labels.extend(['E'])
    elif plot_vals in ['nosurp', 'reg']:
        labels.extend(['D'])
    elif plot_vals == 'diff':
        if op == 'diff':
            labels.extend(['E-D'])      
        elif op == 'ratio':
            labels.extend(['E/D'])
        else:
            gen_util.accepted_values_error('op', op, ['diff', 'ratio'])
    else:
        gen_util.accepted_values_error('plot_vals', plot_vals, 
                                       ['diff', 'reg', 'surp', 'nosurp'])

    if start_fr != -1:
        labels = list(np.roll(labels, -(start_fr+1)))

    return labels


#############################################
def get_subax(ax, i):
    """
    get_subax(ax, i)

    Returns the correct sub_ax based on a 1D index. Indexing is by column, then 
    row.

    Required arguments:
        - ax (plt Axis): axis
        - i (int)      : 1D subaxis index

    Return:
        - sub_ax (plt Axis subplot): subplot
    """
    if len(ax.shape) == 1:
        n = ax.shape[0]
        sub_ax = ax[i%n]
    else:
        ncols = ax.shape[1]
        sub_ax = ax[i/ncols][i%ncols]

    return sub_ax


#############################################
def init_fig(n_subplots, fig_par):
    """
    init_fig(n_subplots, fig_par)

    Creates a figure with the correct number of rows and columns for the 
    number of subplots, following the figure parameters

    Required arguments:
        - n_subplots (int): number of subplots to accomodate in the figure
        - fig_par (dict)  : dictionary containing figure parameters:
                ['ncols'] (int)        : number of columns in the figure
                ['sharey'] (bool)      : if True, y axis lims are shared across 
                                         subplots
                ['subplot_wid'] (float): width of each subplot (inches)
                ['subplot_hei'] (float): height of each subplot (inches)

    Return:
        - fig (plt Fig): fig
        - ax (plt Axis): axis (even if just one subplot)
    """

    if n_subplots == 1:
        ncols = 1
    elif n_subplots < fig_par['ncols']:
        ncols = n_subplots
    else:
        ncols = fig_par['ncols']
    nrows = int(np.ceil(n_subplots/float(fig_par['ncols'])))
    fig, ax = plt.subplots(ncols=ncols, nrows=nrows, 
                           figsize=(ncols*fig_par['subplot_wid'], 
                                    nrows*fig_par['subplot_hei']), 
                           sharey=fig_par['sharey'], squeeze=False)
    return fig, ax


#############################################
def save_fig(fig, save_dir, save_name, fig_par):
    """
    save_fig(fig, save_dir, save_name, fig_par)

    Saves a figure under a specific directory and name, following figure
    parameters and returns final directory name.

    Required arguments:
        - fig (plt Fig)  : figure
        - save_dir (str) : directory in which to save figure
        - save_name (str): name under which to save figure (WITHOUT extension)
        - fig_par (dict) : dictionary containing figure parameters:
                ['bbox'] (str)      : bbox_inches parameter for plt.savefig(),
                                      e.g., 'tight' 
                ['datetime'] (bool) : if True, figures are saved in a subfolder
                                      named based on the date and time.
                ['fig_ext'] (str)   : extension (without '.') with which to save
                                      figure
                ['mult'] (bool)     : if True, prev_dt is created or used.
                ['overwrite'] (bool): if False, overwriting existing figures is 
                                      prevented by adding suffix numbers.
                ['prev_dt'] (str)   : datetime folder to use
    Returns:
        - save_dir (str): final name of the directory in which the figure is 
                          saved 
                          (may be different from input save_dir, as a datetime 
                          subfolder, or a suffix to prevent overwriting may have 
                          been added depending on the parameters in fig_par.)
    """

    print_dir = True

    # add subfolder with date and time
    if fig_par['datetime']:
        if fig_par['mult'] and fig_par['prev_dt'] is not None:
            save_dir = os.path.join(save_dir, fig_par['prev_dt'])
            print_dir = False
        else:
            datetime = str_util.create_time_str()
            save_dir = os.path.join(save_dir, datetime)
            fig_par['prev_dt'] = datetime
    
    # create directory if doesn't exist
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    
    full_save_name = '{}.{}'.format(save_name, fig_par['fig_ext'])

    # check if file aready exists, and if so, add number at end
    if not fig_par['overwrite']:
        if os.path.exists(os.path.join(save_dir, full_save_name)):     
            count = 1
            while os.path.exists(os.path.join(save_dir, '{}_{}.{}'.format(save_name, count, fig_par['fig_ext']))):
                count += 1 
            full_save_name = '{}_{}.{}'.format(save_name, count, fig_par['fig_ext'])

    if print_dir:
        print('Figures saved under {}.'.format(save_dir))

    fig.savefig(os.path.join(save_dir, full_save_name), 
                bbox_inches=fig_par['bbox'])
    
    return save_dir


#############################################
def add_labels(ax, labels, xpos, t_hei=0.9, col='k'):
    """
    add_labels(ax, labels, xpos)

    Adds labels to a subplot.

    Required arguments:
        - ax (plt Axis subplot): subplot
        - labels (list or str) : list of labels to add to to axis
        - xpos (list or float) : list of x coordinates at which to add labels
                                 (same length as labels)
      

    Optional arguments:
        - t_hei (float)        : relative height (from 0 to 1) at which to 
                                 place labels, with respect to y limits
                                 default: 0.9  
        - col (str)            : color to use
                                 default: 'k'
    """

    labels = gen_util.list_if_not(labels)
    xpos = gen_util.list_if_not(xpos)
    if len(labels) != len(xpos):
        raise IOError(('Arguments \'labels\' and \'xpos\' must be of '
                        'the same length.'))
    ymin, ymax = ax.get_ylim()
    ypos = (ymax-ymin)*t_hei+ymin
    for l, x in zip(labels, xpos):
        ax.text(x, ypos, l, ha='center', fontsize=15, color=col)


#############################################
def add_bars(ax, hbars=None, bars=None, col='k'):
    """
    add_bars(ax)

    Adds dashed vertical bars to a subplot.

    Required arguments:
        - ax (plt Axis subplot): subplot

    Optional arguments:
        - hbars (list or float): list of x coordinates at which to add 
                                 heavy dashed vertical bars
                                 default: None
        - bars (list or float) : list of x coordinates at which to add 
                                 dashed vertical bars
                                 default: None
        - col (str)            : color to use
                                 default: 'k'
    """

    torem = []
    if hbars is not None:
        hbars = gen_util.list_if_not(hbars)
        torem = hbars
        for b in hbars:
            ax.axvline(x=b, ls='dashed', c='k', lw='{}'.format(2, alpha=0.5)) 
    if bars is not None:
        bars = gen_util.remove_if(bars, torem)
        for b in bars:
            ax.axvline(x=b, ls='dashed', c='k', lw='{}'.format(1, alpha=0.5)) 


#############################################
def plot_traces(ax, chunk_val, stats='mean', error='std', title='', lw=1.5, 
                col=None, alpha=0.5, plot_err=True, xticks=None, yticks=None,
                label=None, fluor='dff', dff=None):
    """
    plot_traces(ax, chunk_val)

    Plot traces (mean/median with shaded error bars) on axis (ax).

    Required arguments:
        - ax (plt Axis subplot): subplot
        - chunk_val (2D array) : array of chunk statistics, where the first
                                 dimension corresponds to the statistics 
                                 (x_ran [0], mean/median [1], deviation [2] 
                                 or [2:3] if quartiles)
    Optional arguments:
        - stats (str)          : statistic parameter, i.e. 'mean' or 'median'
                                 default: 'mean'
        - error (str)          : error statistic parameter, i.e. 'std' or 'sem'
                                 default: 'std'
        - title (str)          : axis title
        - lw (float)           : plt line weight variable
        - alpha (float)        : plt alpha variable controlling shading 
                                 transparency (from 0 to 1)
        - label (str)          : label for legend
        - fluor (str)          : if 'raw', plot is labeled as raw fluorescence. 
                                 if 'dff, plot is labels with 'dF/F'.
                                 if None, no y label is added.
                                 default: 'dff'
        - dff (bool)           : can be used instead of fluor, and if so
                                 (not None), will supercede fluor. 
                                 if True, fluor is set to 'dff', if False, 
                                 fluor is set to 'raw'. If None, no effect.
                                 default: None  
    """
    
    ax.plot(chunk_val[0], chunk_val[1], lw=lw, color=col, label=label)
    col = ax.lines[-1].get_color()
    if plot_err:
        # only condition where pos and neg error are different
        if stats == 'median' and error == 'std': 
            ax.fill_between(chunk_val[0], chunk_val[2], chunk_val[3], 
                            facecolor=col, alpha=alpha)
        else:
            ax.fill_between(chunk_val[0], chunk_val[1] - chunk_val[2], 
                            chunk_val[1] + chunk_val[2], 
                            facecolor=col, alpha=alpha)

    ax.set_title(title)
    # add x ticks
    min_val = np.min(chunk_val[0])
    max_val = np.around(np.max(chunk_val[0]), 2)
    if min_val == 0:
        if max_val == 1.5:
            ax.set_xticks(np.linspace(min_val, max_val, 6))
        elif max_val == 0.45:
            ax.set_xticks(np.linspace(min_val, max_val, 4))

    if dff is not None:
        if dff:
            fluor = 'dff'
        else:
            fluor = 'raw'
    
    if fluor is not None:
        fluor_str = str_util.fluor_par_str(fluor, type_str='print')
        ax.set_ylabel(fluor_str)
    
    ax.set_xlabel('Time (s)')
    if xticks is not None:
        ax.set_xticks(xticks)
    if yticks is not None:
        ax.set_yticks(yticks)

