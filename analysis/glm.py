"""
glm.py

This module contains functions to run and analyse GLMs predicting ROI activity
from stimulus and behavioural information for data generated by the AIBS 
experiments for the Credit Assignment Project

Authors: Colleen Gillon

Date: September, 2019

Note: this code uses python 3.7.

"""
import copy
import multiprocessing

import glm
import pandas as pd
from sklearn import linear_model

from util import gen_util, math_util


#############################################
def add_columns(df, pars):

    for par in pars:
        if par == 'gabori':
            vals = [0, 45, 90, 135, 180, 225]
        elif par == 'gabfr':
            vals = ['gray_surp', 'gray', 0, 1, 2, 3, 4]
        else:
            gen_util.accepted_values_error('par', par, ['gabori', 'gabfr'])
        uniq_vals = df[par].unique().tolist()    
        if not set(uniq_vals).issubset(set(vals)):
            raise ValueError('Unexpected values for {}.'.format(par))
        mapping = dict()
        for val in vals:
            mapping[val] = 0
        for val in vals:    
            col_name = '{}_{}'.format(par, val)
            this_mapping = copy.deepcopy(mapping)
            this_mapping[val] = 1
            df[col_name] = df[par].copy().replace(this_mapping)
        df = df.drop(columns=par)

    return df



#############################################
def get_mapping(par, uniq_vals):

    if par == 'gabk':
        vals = [4, 16]
    elif par == 'brisize':
        vals = [128, 256]
    elif par == 'bridir':
        vals = ['right', 'left']
    elif par == 'line':
        vals = ['L23-Cux2', 'L5-Rbp4']
    elif par == 'layer':
        vals = ['soma', 'dend']
    else:
        gen_util.accepted_values_error('par', par, ['gabk', 'brisize', 
                                       'bridir', 'line', 'layer'])
    
    if not set(uniq_vals).issubset(set(vals)):
        vals_str = ', '.join(list(set(uniq_vals) - set(vals)))
        raise ValueError('Unexpected value(s) for {}: {}'.format(par, vals_str))

    mapping = dict()
    for i, val in enumerate(vals):
        if val != i:
            mapping[val] = i

    return mapping


#############################################
def build_stim_beh_df(sessions, analyspar, sesspar, stimpar):
    """
    build_stim_beh_df(sessions, stimpar)

    Builds a dataframe containing the stimulus and behavioural information, for 
    each of the specified segments.

    Inputs: sessions, stimtype, segments, pre-post (pupil, running), pre-post (ROI)


    GLM inputs:
    - (Segments (A, B, C, D))
    - Surprise status (only 1 for E and the following grayscreen)
    - Pupil dilation
    - Running speed
    - Layer
    - Line

    """

    full_df = pd.DataFrame()
    retain = ['stimPar1', 'stimPar2', 'surp', 'stimSeg', 'GABORFRAME', 
              'start_frame', 'end_frame']
    drop = ['stimSeg', 'start_twop_fr', 'end_twop_fr', 'start_stim_fr', 
            'end_stim_fr']
    if stimpar.stimtype == 'bricks':
        drop.append('gabfr')
    
    sessions = gen_util.list_if_not(sessions)
    for sess in sessions:
        print('\nBuilding dataframe for session {}'.format(sess.sessid))
        stim = sess.get_stim(stimpar.stimtype)
        sub_df = stim.get_stim_df_by_criteria(gabk=stimpar.gabk, 
                                            bri_dir=stimpar.bri_dir,
                                            bri_size=stimpar.bri_size)[retain]
        sub_df = sub_df.rename(columns={'start_frame': 'start_twop_fr', 
                                        'end_frame': 'end_twop_fr', 
                                        'GABORFRAME': 'gabfr'})
        
        print('Getting stimulus frames by segment.')
        start_stim_fr, end_stim_fr = stim.get_stim_fr_by_seg(sub_df['stimSeg'], 
                                                        first=True, last=True)
        sub_df['start_stim_fr'] = start_stim_fr
        sub_df['end_stim_fr'] = end_stim_fr
        
        if stimpar.stimtype == 'gabors':
            print('    Adding grayscale rows')
            # add in lines for greyscreen with parameters of previous segment
            # except gabfr and start/end frames
            sub_df = sub_df.rename(columns={'stimPar1': 'gabori', 
                                            'stimPar2': 'gabk'})            
            pre_seg = sub_df.loc[(sub_df['gabfr'] == 3)].reset_index(drop=True)
            pre_seg = pre_seg.loc[(pre_seg['stimSeg'] < max(pre_seg['stimSeg']))]

            post_seg = sub_df.loc[(sub_df['gabfr'] == 0)].reset_index(drop=True)
            post_seg = post_seg.loc[(post_seg['stimSeg'] < max(post_seg['stimSeg']))]

            gray_seg = pre_seg.copy()
            gray_seg['gabfr'] = 'gray'
            gray_seg.loc[(gray_seg['gabfr']=='gray') & 
                         (gray_seg['surp']==1), 'gabfr'] = 'gray_surp'
            gray_seg['start_twop_fr'] = gray_seg['end_twop_fr'] + 1
            gray_seg['start_stim_fr'] = gray_seg['end_stim_fr'] + 1
            gray_seg['end_twop_fr']   = post_seg['start_twop_fr'] - 1
            gray_seg['end_stim_fr']   = post_seg['start_stim_fr'] - 1
            sub_df = sub_df.append(gray_seg).reset_index(drop=True)

            sub_df.loc[(sub_df['gabfr'] == 3) & 
                       (sub_df['surp'] == 1), 'gabfr'] = 4
            sub_df.loc[(sub_df['gabfr'] == 4), 'gabori'] += 90

            sub_df = sub_df.drop(columns='surp')

        elif stimpar.stimtype == 'bricks':
            sub_df = sub_df.rename(columns={'stimPar1': 'brisize', 
                                            'stimPar2': 'bridir'})

        else:
            gen_util.accepted_values_error('stimtype', stimpar.stimtype, 
                                           ['bricks', 'gabors'])
        
        sub_df['layer'] = sess.layer
        sub_df['line'] = sess.line
        
        # get running activity
        print('    Getting running activity')
        run_data = stim.get_run_array(sub_df['start_stim_fr'].tolist(), 
                                      stimpar.pre, stimpar.post)[1]
        run_data = math_util.mean_med(run_data, stats=analyspar.stats, axis=-1, 
                                      nanpol='omit')
        sub_df['run_data'] = run_data

        # get pupil diameter
        # pup_fr = sess.get_pup_fr_by_twop_fr(sub_df['start_twop_fr'].tolist())
        # pup_data = stim.get_pup_diam_stats(pup_fr, stimpar.pre, 
        #                 stimpar.post)[1]
        # pup_data = math_util.mean_med(pup_data, stats=analyspar.stats, 
        #                               axis=-1, nanpol='omit')
        # sub_df['pup_data'] = pup_data
        
        # get ROI activity (averaged across frames, then ROIs)
        print('    Getting ROI activity')
        roi_data = stim.get_roi_trace_array(sub_df['start_twop_fr'].tolist(), 
                        stimpar.pre, stimpar.post, fluor=analyspar.fluor)[1]
        for axis in [-1, 0]:
            roi_data = math_util.mean_med(roi_data, stats=analyspar.stats, 
                                          axis=axis, nanpol='omit')
            if axis == -1:
                full_roi_data = copy.deepcopy(roi_data)
                n_rois        = len(full_roi_data) 
        sub_df['roi_data'] = roi_data
        cols = ['roi_data_{}'.format(i) for i in range(n_rois)]
        all_roi = pd.DataFrame(columns=cols, data=full_roi_data.T)
        sub_df = sub_df.join(all_roi)

        # drop columns irrelevant to GLM
        sub_df = sub_df.drop(columns=drop)

        full_df = full_df.append(sub_df)
    
    full_df = full_df.reset_index(drop=True)

    return full_df


#############################################
def run_glm(full_df, analyspar, sesspar, stimpar, reg='ridge'):

    pars = ['layer', 'line']
    if stimpar.stimtype == 'gabors':
        pars.extend(['gabk'])
        full_df = add_columns(full_df, ['gabfr', 'gabori'])
    elif stimpar.stimtype == 'bricks':
        pars.extend(['brisize', 'bridir'])
    else:
        gen_util.accepted_values_error('stimtype', stimpar.stimtype, 
                                        ['bricks', 'gabors'])

    for par in pars:
        uniq_vals = full_df[par].unique().tolist()
        mapping = get_mapping(par, uniq_vals)
        full_df = full_df.replace({par: mapping})

    # drop any column with only one value
    for col in full_df.columns:
        uniq_vals = full_df[col].unique().tolist()
        if len(uniq_vals) == 1:
            full_df = full_df.drop(columns=col)

    print('\nRun regression')
    drop_cols = [col for col in full_df.columns if 'roi_data' in col]
    x_vals = full_df.drop(columns=drop_cols).to_numpy()
    y_vals = full_df['roi_data'].to_numpy()
    # with data split by ROI (and all together)
    y_vals_all = full_df[drop_cols].to_numpy()
    
    alphas=(0.1, 0.1, 2.0)

    if reg == 'ridge':
        regr = linear_model.RidgeCV(normalize=True, alphas=alphas, 
                                    store_cv_values=True)
    elif reg == 'lasso':
        regr = linear_model.LassoLarsCV(normalize=True)
    else:
        gen_util.accepted_values_error('reg', reg, ['ridge', 'lasso'])

    regr.fit(x_vals, y_vals)
    cols = list(full_df.drop(columns=drop_cols).columns)
    
    print('GENERAL REGRESSION')
    print('\n'.join(['{}: {}'.format(col, coef) for col, coef 
                                                in zip(cols, regr.coef_)]))
    print('\nintercept: {}'.format(regr.intercept_))
    print('\nalpha: {}'.format(regr.alpha_))
    if reg == 'lasso':
        print('\nMSEs: {}'.format(regr.mse_path_))
        print('\nn_iter: {}'.format(regr.n_iter_))
    else:
        print('\nCV_vals: {}'.format(regr.cv_values_))

    regr_all = copy.deepcopy(regr)
    regr_all.fit(x_vals, y_vals_all)

    print('SEPARATE REGRESSION')
    # print('\n'.join(['{}: {}'.format(col, coef) for col, coef 
    #                                             in zip(cols, regr.coef_)]))
    # print('\nintercept: {}'.format(regr.intercept_))
    # print('\nalpha: {}'.format(regr.alpha_))
    # if reg == 'lasso':
    #     print('\nMSEs: {}'.format(regr.mse_path_))
    #     print('\nn_iter: {}'.format(regr.n_iter_))
    # else:
    #     print('\nCV_vals: {}'.format(regr.cv_values_))

    return regr, all_regr

