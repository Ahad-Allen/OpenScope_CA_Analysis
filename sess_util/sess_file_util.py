"""
sess_file_util.py

This module contains functions for dealing with reading and writing of data 
files generated by the AIBS experiments for the Credit Assignment Project.

Authors: Blake Richards

Date: August, 2018

Note: this code uses python 3.7.

"""

import os

import glob
import json
import pandas as pd
import pickle

from util import file_util, gen_util


#############################################
def get_sess_dirs(masterdir, sessid, expid, mouseid, runtype='prod',
                  mouse_dir=True):
    """
    get_sess_dirs(masterdir, sessionid, expid, mouseid)

    Returns the full path names of the session directory and subdirectories for 
    the specified session and experiment on the given date that can be used for 
    the Credit Assignment analysis.
 
    Required arguments:
        - masterdir (str): name of the master data directory
        - sessid (int)   : session ID (9 digits), e.g. '712483302'
        - expid (str)    : experiment ID (9 digits), e.g. '715925563'
        - mouseid (str)  : mouse 6-digit ID string used for session files
                           e.g. '389778' 

    Optional arguments
        - runtype (str)   : 'prod' (production) or 'pilot' data
                            default: 'prod'
        - mouse_dir (bool): if True, session information is in a 'mouse_*'
                            subdirectory
                            default: True

    Returns:
        - sessdir (str) : full path name of the session directory
        - expdir (str)  : full path name of the experiment directory
        - procdir (str) : full path name of the processed 
                          data directory
    """
    
    # get the name of the session and experiment data directories
    if mouse_dir:
        sessdir = os.path.join(masterdir, runtype, f'mouse_{mouseid}', 
                               f'ophys_session_{sessid}')
    else:
        sessdir = os.path.join(masterdir, runtype, f'ophys_session_{sessid}')

    expdir = os.path.join(sessdir, f'ophys_experiment_{expid}')
    procdir = os.path.join(expdir, 'processed')

    # check that directory exists 
    try:
        file_util.checkdir(sessdir)
    except OSError:
        raise OSError(f'{sessdir} does not conform to expected AIBS '
                      'structure')

    return sessdir, expdir, procdir


#############################################
def get_file_names(masterdir, sessid, expid, date, mouseid, runtype='prod',
                   mouse_dir=True):
    """
    get_file_names(masterdir, sessionid, expid, date, mouseid)

    Returns the full path names of all of the expected data files in the 
    main_directory for the specified session and experiment on the given date 
    that can be used for the Credit Assignment analysis.
 
    Required arguments:
        - masterdir (str): name of the master data directory
        - sessid (int)   : session ID (9 digits), e.g. '712483302'
        - expid (str)    : experiment ID (9 digits), e.g. '715925563'
        - date (str)     : date for the session in YYYYMMDD
                           e.g. '20160802'
        - mouseid (str)  : mouse 6-digit ID string used for session files
                           e.g. '389778' 

    Optional arguments
        - runtype (str)   : 'prod' (production) or 'pilot' data
                            default: 'prod'
        - mouse_dir (bool): if True, session information is in a 'mouse_*'
                            subdirectory
                            default: True

    Returns:
        - expdir (str)    : full path name of the experiment directory
        - procdir (str)   : full path name of the processed 
                            data directory
        - filepaths (dict): dictionary of file paths
            ['behav_video_h5'] (str)   : full path name of the behavioral hdf5
                                         video file
            ['align_pkl'] (str)        : full path name of the stimulus
                                         alignment pickle file
            ['corrected_data_h5'] (str): full path name of the motion
                                         corrected 2p data hdf5 file
            ['pupil_video_h5'] (str)   : full path name of the pupil hdf5 video
                                         file
            ['roi_trace_h5'] (str)     : full path name of the ROI raw 
                                         fluorescence trace hdf5 file
            ['roi_trace_dff_h5'] (str) : full path name of the ROI dF/F trace 
                                         hdf5 file
            ['stim_pkl']  (str)        : full path name of the stimulus
                                         pickle file
            ['stim_sync_h5'] (str)     : full path name of the stimulus
                                         synchronization hdf5 file
            ['time_sync_h5'] (str)     : full path name of the time 
                                         synchronization hdf5 file
            ['zstack_h5'] (str)        : full path name of the zstack 2p hdf5 
                                         file
    """
    
    sessdir, expdir, procdir = get_sess_dirs(masterdir, sessid, expid, 
                                             mouseid, runtype, mouse_dir)

    # set the file names
    sess_m_d = f'{sessid}_{mouseid}_{date}' 

    filepaths = {'align_pkl'        : os.path.join(sessdir, 
                                      f'{sess_m_d}_df.pkl'),
                 'behav_video_h5'   : os.path.join(sessdir, 
                                      f'{sess_m_d}_video-0.h5'),
                 'correct_data_h5'  : os.path.join(procdir, 'concat_31Hz_0.h5'),
                 'pupil_video_h5'   : os.path.join(sessdir, 
                                      f'{sess_m_d}_video-1.h5'),
                 'roi_trace_h5'     : os.path.join(procdir, 'roi_traces.h5'),
                #  'roi_trace_dff_h5' : os.path.join(procdir, 
                #                       'roi_traces_dff.h5'),
                 'roi_trace_dff_h5' : os.path.join(expdir, f'{expid}_dff.h5'),
                 'stim_pkl'         : os.path.join(sessdir, 
                                      f'{sess_m_d}_stim.pkl'),
                 'stim_sync_h5'     : os.path.join(sessdir, 
                                      f'{sess_m_d}_sync.h5'),
                 
                 'time_sync_h5'     : os.path.join(expdir, 
                                      f'{expid}_time_synchronization.h5'),
                 'zstack_h5'        : os.path.join(sessdir, 
                                      f'{sessid}_zstack_column.h5'),
                }
    
    # files not to check for (will be created if needed or 
    # not  currently needed)
    no_check = ['align_pkl', 'roi_trace_dff_h5', 'correct_data_h5', 'zstack_h5']

    for key in filepaths.keys():
        if key not in no_check and not os.path.isfile(filepaths[key]):
            raise OSError(f'{filepaths[key]} does not exist')

    return [expdir, procdir, filepaths]


#############################################
def get_sess_dir_path(masterdir, runtype, sessid):
    """
    get_sess_dir_path(masterdir, runtype, sessid)

    Returns the path to the session directory, and whether a mouse directory 
    is included in the path.

    Required args:
        - masterdir (str): master directory
        - runtype (str)  : runtype ('prod' or 'pilot')
        - sessid (int)   : session ID

    Returns:
        - sess_dir (str)  : path to the session directory
        - mouse_dir (bool): if True, path includes a mouse directory. 
    """

    if runtype not in ['pilot', 'prod']:
        gen_util.accepted_values_error('runtype', runtype, ['prod', 'pilot'])

    # set the session directory (full path)
    wild_dir  = os.path.join(masterdir, runtype, 'mouse_*', 
                             f'ophys_session_{sessid}')
    name_dir  = glob.glob(wild_dir)
    
    # pilot data may not be in a 'mouse_' folder
    if len(name_dir) == 0:
        wild_dir  = os.path.join(masterdir, runtype,  
                                 f'ophys_session_{sessid}')
        name_dir  = glob.glob(wild_dir)
        mouse_dir = False
    else:
        mouse_dir = True

    if len(name_dir) == 0:
        raise OSError(f'Could not find directory for session {sessid} '
                      f'in {masterdir} subfolders')
    elif len(name_dir) > 1:
        raise OSError(f'Found {len(name_dir)} matching session folders in '
                      f'{masterdir} instead of 1.')

    sess_dir = name_dir[0]

    return sess_dir, mouse_dir


#############################################
def get_mouse_date(sessdir, sessid):
    """
    get_mouse_date(sessdir, runtype, sessid)

    Returns the date and mouse ID associated with a session.

    Required args:
        - sessdir (str): session directory
        - sessid (int) : session ID

    Returns:
        - date (str)     : session date (i.e., yyyymmdd)
        - mouse_dir (int): mouse ID (6 digits)
    """

    pklglob = glob.glob(os.path.join(sessdir, f'{sessid}*stim.pkl'))
    
    if len(pklglob) == 0:
        raise OSError(f'Could not find stim pkl file in {sessdir}')
    else:
        pklinfo = os.path.basename(pklglob[0]).split('_')
    
    mouseid = int(pklinfo[1]) # mouse 6 digit nbr
    date    = pklinfo[2]

    return mouseid, date


#############################################
def get_expid(sessdir):
    """
    get_expid(sessdir)

    Returns the experiment ID associated with a session.

    Required args:
        - sessdir (str): session directory

    Returns:
        - expid (int): experiment ID (8 digits)

    """

    expglob = glob.glob(os.path.join(sessdir,'ophys_experiment*'))
    if len(expglob) == 0:
        raise OSError('Could not find experiment directory '
                      f'in {sessdir}')
    else:
        expinfo = os.path.basename(expglob[0]).split('_')
    expid = int(expinfo[2])

    return expid


#############################################
def get_mask_path(masterdir, sessid, expid, mouseid, runtype='prod', 
                  mouse_dir=True):
    """
    get_mask_path(masterdir, sessid, expid, mouseid)

    Returns path to mask file (checks for actual and previous version of names, 
    but if both or neither are found, raises an error).

    Required args:
        - masterdir (str): name of the master data directory
        - sessid (int)   : session ID (9 digits), e.g. '712483302'
        - expid (str)    : experiment ID (9 digits), e.g. '715925563'
        - date (str)     : date for the session in YYYYMMDD
                           e.g. '20160802'
        - mouseid (str)  : mouse 6-digit ID string used for session files
                           e.g. '389778' 

    Optional args:
        - runtype (str)   : 'prod' (production) or 'pilot' data
                            default: 'prod'
        - mouse_dir (bool): if True, session information is in a 'mouse_*'
                            subdirectory
                            default: True

    Returns:
        - maskfile (str): full path name of the extract masks hdf5 file
    """

    _, _, procdir = get_sess_dirs(masterdir, sessid, expid, mouseid, runtype, 
                                  mouse_dir)


    maskfile = os.path.join(procdir, f'{sessid}_dendritic_masks.h5')

    found = 0
    if os.path.exists(maskfile):
        found += 1
    
    # try previous mask file name
    prev_maskfile = os.path.join(procdir, f'{sessid}_extract_masks.h5')

    if os.path.exists(prev_maskfile):
        found +- 1
        maskfile = prev_maskfile

    if found == 1:
        return maskfile
    else:
        file_str = ' or '.join([maskfile, prev_maskfile])
        if found == 0:
            raise OSError(f'No dendritic masks found under \'{file_str}\'')
        else:
            raise OSError(f'Multiple dendritic masks found under \'{file_str}\'')


#############################################
def get_dendritic_trace_paths(trace_file):
    """
    get_dendritic_trace_paths(trace_file)

    Returns path to traces for EXTRACT dendritic trace data (checks for actual 
    and previous version of names, but if both are found or only dF/F is found, 
    raises an error). 
    Does not raise an error if none are found, but returns 'none' for each.

    Required args:
        - trace_file (str): path to ROI traces

    Returns:
        - dend_tr_file (str)    : path to EXTRACT dendritic ROI traces ('none' 
                                  if none found)
        - dend_tr_dff_file (str): path to EXTRACT dendritic ROI dF/F 
                                  traces ('none' if none found)
    """

    filepath, ext = os.path.splitext(trace_file)
    
    dend_part = '_dendritic'
    prev_dend_part = '_extr'

    if dend_part in trace_file:
        filepath = trace_file.replace(dend_part, '')

    act_dend_tr_file = f'{filepath}{dend_part}{ext}'
    act_dend_tr_dff_file = f'{filepath}{dend_part}_dff{ext}'

    prev_dend_tr_file = f'{filepath}{prev_dend_part}{ext}'
    prev_dend_tr_dff_file = f'{filepath}_dff{prev_dend_part}{ext}'

    dend_tr_file, dend_tr_dff_file = 'none', 'none'
    found = 0
    for dend_tr, dend_tr_dff in [[act_dend_tr_file, act_dend_tr_dff_file], 
                                 [prev_dend_tr_file, prev_dend_tr_dff_file]]:
        first = True
        if os.path.exists(dend_tr_dff): # check for dF/F
            first = False
            found += 1
        if os.path.exists(dend_tr):
            dend_tr_file = dend_tr
            dend_tr_dff_file = dend_tr_dff
            if first:
                found += 1

    if found > 1:
        raise ValueError('2 sets of EXTRACT dendritic ROI traces found '
                         'with different naming patterns.')

    if dend_tr_dff != 'none' and dend_tr_dff == 'none': 
        raise ValueError('Found only dF/F traces, not raw.')

    return dend_tr_file, dend_tr_dff_file


#############################################
def get_pupil_data_h5_path(masterdir):
    """
    get_pupil_data_h5_path(masterdir)

    Returns path to pupil data h5 file.

    Required args:
        - masterdir (str): name of the master data directory

    Returns:
        - pup_data_h5 (str): if full path name of the pupil h5 file
    """

    name_part = '*pupil_data_df.h5'
    pupil_data_files = glob.glob(os.path.join(masterdir, name_part))

    if len(pupil_data_files) == 1:
        pup_data_h5 = pupil_data_files[0]
    elif len(pupil_data_files) > 1:
        pup_data_h5 = pupil_data_files
    else:
        pup_data_h5 = 'none'

    return pup_data_h5

