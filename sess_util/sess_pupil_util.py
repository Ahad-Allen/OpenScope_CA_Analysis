"""
sess_pupil_util.py

This module contains functions for extracting pupil diameter information from
the pupil tracking data generated by the AIBS experiments for the Credit 
Assignment Project.

Authors: Jay Pina

Date: July, 2019

Note: this code uses python 3.7.

"""

import numpy as np


#############################################
def eye_diam_center(M):
    """
    Returns the approximated pupil diameter, center, and frame-by-frame
    center differences (approximate derivative).  All in pixels.
    """
    
    # ordering of data (from config.yaml)is (w = whatever): 
    # w, left x2, w, right x2, w, top x2, w, bottom x2, w, 
    # lower left x2, w, upper left x2, w, upper right x2, w, lower right x2, w
    x = M[ :, [1,4,7,10,13,16,19,22] ]
    y = M[ :, [2,5,8,11,14,17,20,23] ]
    
    # dx and dy are pairwise distances of points furthest apart; ordering:
    # left -- right, top -- bottom, lower left -- upper right, upper left --
    # lower right
    dx = np.zeros( [x.shape[0], 4] )
    dy = np.zeros( [x.shape[0], 4] )
    dx[:,0] = np.abs( x[:,0]-x[:,1] )
    dx[:,1] = np.abs( x[:,2]-x[:,3] )
    dx[:,2] = np.abs( x[:,4]-x[:,6] )
    dx[:,3] = np.abs( x[:,5]-x[:,7] )
    dy[:,0] = np.abs( y[:,0]-y[:,1] )
    dy[:,1] = np.abs( y[:,2]-y[:,3] )
    dy[:,2] = np.abs( y[:,4]-y[:,6] )
    dy[:,3] = np.abs( y[:,5]-y[:,7] )
    
    
    # find diameters
    diams = np.sqrt( dx**2 + dy**2 )
    #max_diam = np.max( diams )
    #mean_diam = np.mean( diams )
    median_diam = np.median( diams, axis=1 )
    #min_diam = np.min( diams )
    
    # find centers and frame-to-frame differences
    center = np.transpose( [np.mean( x,axis=1 ), np.mean( y,axis=1 )] )
    center_diff = np.diff( center, axis=0 )
    center_dist_diff = np.sqrt( center_diff[:,0]**2 + center_diff[:,1]**2 )
    
    return median_diam, center, center_dist_diff


#############################################
def diam_no_blink(diam, thr=5):
    """
    Returns the diameter without large deviations likely caused by blinks
    """

    nan_diam = diam

    #Find aberrant blocks:
    diam_diff = np.append( 0, np.diff(diam) )
    diam_thr = np.where( np.abs(diam_diff) > thr )[0]
    diam_thr_diff = np.append( 1, np.diff(diam_thr) ) 
    
    diff_thr = 10 #how many consecutive frames should be non-aberrant
    searching = 1
    i = 0
    while( searching ):
        left = diam_thr[i]
        w =  np.where( diam_thr_diff[ i+1 : diam_thr_diff.size+1 
                                                  ] > diff_thr )[0]
        if w.size: #i.e., non-empty array
            right_i = np.min( w+i+1 ) - 1
            right = diam_thr[right_i]
        else:
            right = diam_thr[-1]
            searching = 0
        i = right_i + 1
        nan_diam[left:right+1] = np.nan
        
    return nan_diam
        
