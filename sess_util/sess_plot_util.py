"""
sess_plot_util.py

This module contains basic functions for plotting with pyplot data generated by 
the AIBS experiments for the Credit Assignment Project.

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 3.7.

"""

import os

import numpy as np

from util import gen_util, plot_util
from sess_util import sess_str_util


#############################################
def init_figpar(ncols=4, sharex=False, sharey=True, subplot_hei=7.5, 
                subplot_wid=7.5, datetime=True, use_dt=None, fig_ext='svg', 
                overwrite=False, runtype='prod', output='.', plt_bkend=None, 
                linclab=True, fontdir=None):
    
    """
    Returns a dictionary containing figure parameter dictionaries for 
    initializing a figure, saving a figure, and extra save directory 
    parameters.

    Required args: 
        - ncols (int)      : number of columns in the figure
                             default: 4 
        - sharex (bool)    : if True, x axis lims are shared across subplots
                             default: False 
        - sharey (bool)    : if True, y axis lims are shared across subplots
                             default: True
        - subplot_hei (num): height of each subplot (inches)
                             default: 7.5
        - subplot_wid (num): width of each subplot (inches)
                             default: 7.5
        - datetime (bool)  : if True, figures are saved in a subfolder named 
                             based on the date and time.
        - use_dt (str)     : datetime folder to use
                             default: None
        - fig_ext (str)    : figure extension
                             default: 'svg'
        - overwrite (bool) : if False, overwriting existing figures is 
                             prevented by adding suffix numbers.
                             default: False
        - runtype (str)    : runtype ('pilot', 'prod')
                             default: 'prod'
        - output (str)     : general directory in which to save output
                             default: '.'

    Returns:
        - figpar (dict): dictionary containing figure parameters:
            ['init'] : dictionary containing the following inputs as
                       attributes:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
            ['save'] : dictionary containing the following inputs as
                       attributes:
                           datetime, use_dt, fig_ext, overwrite
            ['dirs']: dictionary containing the following attributes:
                ['figdir'] (str)   : main folder in which to save figures
                ['roi'] (str)      : subdirectory name for ROI analyses
                ['run'] (str)      : subdirectory name for running analyses
                ['autocorr'] (str) : subdirectory name for autocorrelation 
                                     analyses
                ['full'] (str)     : subdirectory name for full trace plots
                ['locori'] (str)   : subdirectory name for location and 
                                     orientation responses
                ['posori'] (str)   : subdirectory name for position and 
                                     orientation plots
                ['pupil'] (str)    : subdirectory for pupil analyses
                ['oridir'] (str)   : subdirectory name for 
                                     orientation/direction analyses
                ['surp_qu'] (str)  : subdirectory name for surprise, quintile 
                                     analyses
                ['tune_curv'] (str): subdirectory name for tuning curves
                ['grped'] (str)    : subdirectory name for ROI grps data
                ['mags'] (str)     : subdirectory name for magnitude analyses
                
            ['mng']: dictionary containing the following attributes:
                ['plt_bkend'] (str): mpl backend to use
                ['linclab'] (bool) : if True, Linclab mpl defaults are used
                ['fontdir'] (str)  : path to directory containing additional 
                                     fonts
    """

    fig_init = {'ncols'      : ncols,
                'sharex'     : sharex,
                'sharey'     : sharey, 
                'subplot_hei': subplot_hei,
                'subplot_wid': subplot_wid
                }

    fig_save = {'datetime' : datetime,
                'use_dt'   : use_dt,
                'fig_ext'  : fig_ext,
                'overwrite': overwrite
                }
    
    fig_mng = {'linclab'  : linclab,
               'plt_bkend': plt_bkend,
               'fontdir'  : fontdir,
                }

    figdir = os.path.join(output, 'results', 'figures')

    fig_dirs = {'figdir'   : figdir,
                'roi'      : os.path.join(figdir, '{}_roi'.format(runtype)),
                'run'      : os.path.join(figdir, '{}_run'.format(runtype)),
                'autocorr' : 'autocorr',
                'full'     : 'full',
                'posori'   : 'posori',
                'pupil'    : 'pupil',
                'oridir'   : 'oridir',
                'surp_qu'  : 'surp_qu',
                'tune_curv': 'tune_curves',
                'grped'    : 'grped',
                'mags'     : 'mags',
               }

    figpar = {'init' : fig_init,
              'save' : fig_save,
              'dirs' : fig_dirs,
              'mng'  : fig_mng
              }
    
    return figpar


#############################################
def get_quint_cols(n_quints=4):
    """
    get_quint_cols()

    Returns regular and surprise colors for quintiles, as well as label colors
    for regular and surprise.

    Required args:
        - n_quints (int): number of quintiles

    Returns:
        - cols (list)    : nested list of colors, 
                           structured as [regular, surprise]
        - lab_cols (list): label colors for regular and surprise data
    """
    # prev: '#50a2d5', 'cornflowerblue', 'steelblue', 'dodgerblue', 
    #       'mediumblue', 'darkblue', 'royalblue'
    col_reg  = ['#7cc7f9', '#50a2d5', '#2e78a9', '#16547d']
    main_reg = 1
    
    # prev: '#eb3920', 'tomato', 'salmon', 'coral', 'orangered', 'indianred', 
    #       'firebrick'
    col_surp = ['#f36d58', '#eb3920', '#c12a12', '#971a07']
    main_surp = 1

    max_qu = np.max([len(col_reg), len(col_surp)])
    if n_quints > max_qu:
        raise NotImplementedError(('Not enough colors preselected for more '
                                    'than 4 quintiles.'))

    cols = []
    for main, all_cols in zip([main_reg, main_surp], [col_reg, col_surp]):
        if n_quints <= (max_qu - main):
            cols.append(all_cols[main : main + n_quints])
        else:
            cols.append(all_cols[: n_quints])

    lab_cols = [col_reg[main_reg], col_surp[main_surp]]

    return cols, lab_cols


#############################################
def add_axislabels(sub_ax, fluor='dff', area=False, scale=False, datatype='roi', 
                   x_ax=None, y_ax=None):
    """
    add_axislabels(sub_ax)

    Adds the appropriate labels to the subplot x and y axes. 
    
    If y_ax is None, y axis is assumed to be fluorescence, and label is 
    inferred from fluor and dff parameters. If x_ax is None, x axis is assumed
    to be time in seconds.

    Required args:
        - sub_ax (plt Axis subplot): subplot

    Optional args:
        - fluor (str)   : if y_ax is None, whether 'raw' or processed 
                          fluorescence traces 'dff' are plotted. 
                          default: 'dff'
        - area (bool)   : if True, 'area' is added after the y_ax label
                          default: False
        - scale (bool)  : if True, '(scaled)' is added after the y_ax label
                          default: False
        - datatype (str): type of data, either 'run' or 'roi'
                          default: 'roi'
        - x_ax (str)    : label to use for x axis.
                          default: None
        - y_ax (str)    : label to use for y axis.
                          default: None
    """
    
    area_str = ''
    if area:
        area_str = ' area'

    scale_str = ''
    if scale:
        scale_str = ' (scaled)'

    if x_ax is None:
        x_str = 'Time (s)'
    else:
        x_str = x_ax
    sub_ax.set_xlabel(x_str)

    if y_ax is None:
        if datatype == 'roi':
            y_str = sess_str_util.fluor_par_str(fluor, str_type='print')
        elif datatype == 'run':
            y_str = 'Running speed (cm/s)'
        else:
            gen_util.accepted_values_error('datatype', datatype, ['roi', 'run'])
    else:
        y_str = y_ax
    sub_ax.set_ylabel(u'{}{}{}'.format(y_str, area_str, scale_str))


#############################################
def get_fr_lab(plot_vals='both', op='diff', start_fr=-1):
    """
    get_fr_lab()

    Returns a list of labels for gabor frames based on values that are plotted,
    and operation on surprise v no surprise, starting with gray.

    Optional args:
        - plot_vals (str): values plotted ('surp', 'reg', 'both')
                           default: 'both'
        - op (str)       : operation on the values, if both ('ratio' or 'diff')
                           default: 'diff'
        - start_fr (int) : starting gabor frame 
                           (-1: gray, 0: A, 1: B, 2:C, 3:D/E)
                           default: -1
    
    Returns:
        - labels (list)  : list of labels for gabor frames
    """

    labels = ['gray', 'A', 'B', 'C']

    if plot_vals == 'surp':
        labels.extend(['E'])
    elif plot_vals == 'reg':
        labels.extend(['D'])
    elif plot_vals == 'both':
        if op == 'diff':
            labels.extend(['E-D'])      
        elif op == 'ratio':
            labels.extend(['E/D'])
        else:
            gen_util.accepted_values_error('op', op, ['diff', 'ratio'])
    else:
        gen_util.accepted_values_error('plot_vals', plot_vals, 
                                       ['both', 'reg', 'surp'])

    if start_fr != -1:
        labels = list(np.roll(labels, -(start_fr+1)))

    return labels


#############################################
def get_seg_comp(gabfr=0, plot_vals='both', op='diff', pre=0, post=1.5):
    """
    get_seg_comp()

    Returns lists with different components needed when plotting segments, 
    namely positions of labels, ordered labels, positions of heavy bars and 
    position of regular bars.

    Optional args:
        - gabfr (int)    : gabor frame of reference
                           default: 0
        - plot_vals (str): values plotted ('surp', 'reg', 'both')
                           default: 'both'
        - op (str)       : operation on the values, if both ('ratio' or 'diff')
                           default: 'diff'
        - pre (num)      : range of frames to include before reference frame 
                           (in s)
                           default: 0 (only value implemented)
        - post (num)     : range of frames to include after reference frame
                           (in s)
                           default: 1.5 (only value implemented)
    
    Returns:
        - xpos (list)          : list of x coordinates at which to add labels
                                 (same length as labels)
        - labels (list)         : ordered list of labels for gabor frames
        - hbars (list or float): list of x coordinates at which to add 
                                 heavy dashed vertical bars
        - bars (list or float) : list of x coordinates at which to add 
                                 dashed vertical bars
    """

    if gabfr not in list(range(0, 4)):
        raise ValueError('Gabor frame must be 0, 1, 2 or 3.')

    seg_len = 0.3

    pre_segs = int(np.floor(pre/seg_len)) # number of segs pre
    n_segs = int(np.floor((pre + post)/seg_len)) # number of segs
    xpos = [(x + 0.5 - pre_segs) * seg_len for x in range(n_segs)]
    bars = [(x - pre_segs) * seg_len for x in range(n_segs)]
    
    labels = get_fr_lab(plot_vals, op, gabfr - pre_segs)
    if len(labels) < len(xpos):
        labels = labels * (len(xpos)//len(labels) + 1)
    if len(labels) > len(xpos):
        labels = labels[:len(xpos)]

    hbars = [bars[x] for x in range(1, len(bars)) if labels[x-1] == 'C']
    bars = gen_util.remove_if(bars, [-pre] + hbars)
    hbars = gen_util.remove_if(hbars, -pre)

    return xpos, labels, hbars, bars


#############################################
def plot_labels(ax, gabfr=0, plot_vals='both', op='none', pre=0, post=1.5, 
                cols=None, sharey=True, t_heis=[0.85, 0.75], incr=True):
    """
    plot_labels()

    Plots lines and labels for gabors segments.
   
    Required args:
        - ax (plt Axis): axis

    Optional args:
        - gabfr (int)    : gabor frame of reference
                           default: 0
        - plot_vals (str): values plotted ('surp', 'reg', 'comb', 'both')
                           default: 'both'
        - op (str)       : operation on the values, if both ('ratio' or 'diff')
                           default: 'none'
        - pre (num)      : range of frames to include before reference frame 
                           (in s)
                           default: 0 (only value implemented)
        - post (num)     : range of frames to include after reference frame
                           (in s)
                           default: 1.5 (only value implemented)
        - cols (str)     : colors to use for labels
                           default: None
        - sharey (bool)  : if True, y axes are shared
                           default: True
        - t_heis (list)  : height(s) at which to place labels. If t_hei 
                           includes negative values, the ylims are not 
                           modified.
                           default: [0.85, 0.75]
    """

    t_heis = gen_util.list_if_not(t_heis)
    if cols is None:
        cols = ['k', 'k']

    min_t_hei = min(t_heis)
    if min_t_hei > 0:
        plot_util.incr_ymax(ax, incr=1.05/min_t_hei, sharey=sharey)

    if plot_vals == 'both':
        if op == 'none':
            plot_vals = ['reg', 'surp']

    plot_vals = gen_util.list_if_not(plot_vals)

    n_ax = np.product(ax.shape)
    for i in range(n_ax):
        sub_ax = plot_util.get_subax(ax, i)
        for i, pv in enumerate(plot_vals):
            [xpos, lab, h_bars, 
                       seg_bars] = get_seg_comp(gabfr, pv, op, pre, post)
            plot_util.add_labels(sub_ax, lab, xpos, t_heis[i], cols[i])
        plot_util.add_bars(sub_ax, hbars=h_bars, bars=seg_bars)


#############################################
def plot_gabfr_pattern(sub_ax, x_ran, alpha=0.1, offset=0, bars_omit=[]):
    """
    plot_gabfr_pattern(sub_ax, x_ran)

    Plots light dashed lines at the edges of each gabor sequence and shades
    D/E segments.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - x_ran (array-like)       : range of x axis values

    Optional args:
        - alpha (num)     : plt alpha variable controlling shading 
                            transparency (from 0 to 1)
                            default: 0.1
        - offset (num)    : offset of sequence edges from 0
                            default: 0
        - bars_omit (list): positions at which to omit bars (e.g., in case they 
                            would be redundant)
                            default: []
    """

    bars = plot_util.get_repeated_bars(np.min(x_ran), np.max(x_ran), 1.5, 
                                       offset=offset)
    shade_st = [bar - 0.6 + offset for bar in bars 
                                   if (bar - 0.6 + offset) > x_ran[0]]
    bars = gen_util.remove_if(bars, bars_omit)
    plot_util.add_bars(sub_ax, bars=bars)
    plot_util.add_vshade(sub_ax, shade_st, width=0.3, alpha=0.1)