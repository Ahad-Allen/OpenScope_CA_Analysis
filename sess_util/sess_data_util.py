"""
sess_data_util.py

This module contains functions for dealing with data generated by the AIBS 
experiments for the Credit Assignment Project.

Authors: Colleen Gillon

Date: August, 2018

Note: this code uses python 3.7.

"""

import copy
import numpy as np

from util import data_util, gen_util, math_util


#############################################
def get_stim_data(sess, stimtype, win_leng_s, gabfr=0, pre=0, post=1.5, 
                  surp='any', step_size=1, gabk=16, run=True, run_mean=None, 
                  run_std=None):

    """
    get_stim_data(sess, stimtype, win_leng_s)

    Returns stimulus data (x position, y position, size, orientation, each 
    scaled based on its maximal range), and optionally running for windows 
    taken for the each of the segments of interest.

    Required args:
        - sess (Session)    : session
        - stimtype (str)    : stimulus type ('gabors'or 'bricks')
        - win_leng_s (num)  : window length in seconds
    
    Optional args:
        - gabfr (int)            : gabor reference frame for determining the
                                   2p frames in each sequence
                                   default: 0 
        - pre (num)              : number of frames to include before reference
                                   gabor frame in each sequence (in sec)
                                   default: 0
        - post (num)             : number of frames to include after reference
                                   gabor frame in each sequence (in sec)
                                   default: 1.5
        - surp (str, list or int): surprise value criteria for including 
                                   reference gabor frames (0, 1, or 'any')
                                   default: 'any'
        - step_size (int)        : step size between windows
                                   default: 1
        - gabk (int or list)     : gabor kappa criteria for including reference
                                   gabor frames (4, 16 or 'any')
                                   default: 16
        - run (bool)             : if True, running data is appended to the
                                   end of the stimulus data
                                   default: True
        - run_mean (num)         : mean value with which to scale running 
                                   data, if running data is included. If 
                                   run_mean or run_std is None, both are 
                                   calculated from the running data retrieved 
                                   and returned as outputs.
                                   default: None
        - run_std (num)          : standard deviation value with which to 
                                   scale running data, if running data is 
                                   included. If run_mean or run_std is None, 
                                   both are calculated from the running data 
                                   retrieved and returned as outputs.
                                   default: None
    
    Returns:
        - stim_wins (3D array): array of stimulus data, structured as:
                                seq wins x frames x pars, where the pars are:
                                    - for each gabor: x_pos, y_pos, size, ori 
                                    - run velocity
        if run and run_mean or run_std is None:
        - (list):
            - run_mean (num)  : mean of retrieved running values
            - run_std (num)   : standard deviation of retrieved running values

    """

    if win_leng_s > (pre + post):
        raise ValueError('Windows cannot be longer than the sequences.')

    stim = sess.get_stim(stimtype)

    segs = stim.get_segs_by_criteria(gabfr=gabfr, gabk=gabk, surp=surp, 
                                     by='seg')
    twopfr = stim.get_twop_fr_by_seg(segs, first=True)

    # get stim params as seq x frame x gabor x par (x, y, ori, size)
    # each param scaled to between -1 and 1 based on known ranges
    # from which they were sampled
    pars = stim.get_stim_par_by_twopfr(twopfr, pre, post, scale=True)
    pars = np.stack(pars).transpose([1, 2, 3, 0])

    if run:
        twop_fr_seqs = sess.get_twop_fr_ran(twopfr, pre, post)[0]
        run_velocity = sess.get_run_velocity(twop_fr_seqs)
        
        # scale running array to mean 0 with std 1
        ret_run_stats = False
        if run_mean is None or run_std is None:
            ret_run_stats = True
            run_mean = np.mean(run_velocity)
            run_std  = np.std(run_velocity)
        run_velocity = 2. * (run_velocity - run_mean)/run_std - 1.

    # stim params: seq x frame x flat (gab x pars)
    all_pars = pars.reshape([pars.shape[0], pars.shape[1], -1])
    if run:
        all_pars = np.concatenate([all_pars, run_velocity[:, :, np.newaxis]], 
                                   axis=2)
    
    win_leng = int(np.floor(win_leng_s * sess.twop_fps))

    stim_wins = []
    for seq_pars in all_pars:
        stim_wins.append(data_util.window_2d(seq_pars, win_leng, 
                                             step_size=step_size))

    stim_wins = np.concatenate(stim_wins, axis=0).transpose([0, 2, 1])

    if run and ret_run_stats:
        return stim_wins, [run_mean, run_std]
    else:
        return stim_wins


#############################################
def get_roi_data(sess, stimtype, win_leng_s, gabfr=0, pre=0, post=1.5, 
                 surp='any', step_size=1, gabk=16, roi_means=None, 
                 roi_stds=None):
    """
    get_roi_data(sess, stimtype, win_leng_s)

    Returns stimulus data (x position, y position, size, orientation, each 
    scaled based on its maximal range), and optionally running for windows 
    taken for the each of the segments of interest.

    Required args:
        - sess (Session)    : session
        - stimtype (str)    : stimulus type ('gabors'or 'bricks')
        - win_leng_s (num)  : window length in seconds
    
    Optional args:
        - gabfr (int)            : gabor reference frame for determining the
                                   2p frames in each sequence
                                   default: 0 
        - pre (num)              : number of frames to include before reference
                                   gabor frame in each sequence (in sec)
                                   default: 0
        - post (num)             : number of frames to include after reference
                                   gabor frame in each sequence (in sec)
                                   default: 1.5
        - surp (str, list or int): surprise value criteria for including 
                                   reference gabor frames (0, 1, or 'any')
                                   default: 'any'
        - step_size (int)        : step size between windows
                                   default: 1
        - gabk (int or list)     : gabor kappa criteria for including reference
                                   gabor frames (4, 16 or 'any')
                                   default: 16
        - roi_means (1D array)   : mean values for each ROI with which to 
                                   scale trace data. If roi_means or 
                                   roi_stds is None, both are calculated from 
                                   the trace data retrieved and returned as 
                                   outputs.
                                   default: None
        - roi_stds (1D array)    : standard deviation values for each ROI with 
                                   which to scale trace data. If roi_means 
                                   or roi_stds is None, both are calculated 
                                   from the trace data retrieved and returned  
                                   as outputs.
                                   default: None
    
    Returns:
        - xran (1D array)      : time values for the 2p frames
        - trace_wins (3D array): array of ROI data, structured as:
                                 seq wins x frames x ROI
        if roi_means or roi_stds is None:
        - (list):
            - roi_means (1D array): trace means for each ROI
            - roi_stds (1D array) : trace standard deviations for each ROI

    """


    if win_leng_s > (pre + post):
        raise ValueError('Windows cannot be longer than the sequences.')

    stim = sess.get_stim(stimtype)

    segs = stim.get_segs_by_criteria(gabfr=gabfr, gabk=gabk, surp=surp, 
                                     by='seg')
    twopfr = stim.get_twop_fr_by_seg(segs, first=True)
    
    xran, traces = stim.get_roi_trace_array(twopfr, pre, post)
    ret_roi_stats = False

    # scale each ROI to mean 0, std 1
    if roi_means is None or roi_stds is None:
        ret_roi_stats = True
        roi_means = np.mean(traces.reshape(traces.shape[0], -1), axis=1)
        roi_stds  = np.std(traces.reshape(traces.shape[0], -1), axis=1)
    traces = 2. * (traces - roi_means.reshape([-1, 1, 1]))/ \
                  roi_stds.reshape([-1, 1, 1]) - 1.
    # traces: seq x frames x ROI
    traces = traces.transpose(1, 2, 0)

    trace_wins = []
    win_leng = int(np.floor(sess.twop_fps * win_leng_s))
    for seq_traces in traces:
        # n_wins x n_ROIs x win_leng
        trace_wins.append(data_util.window_2d(seq_traces, win_leng, 
                                              step_size=step_size))
    # concatenate windows
    trace_wins = np.concatenate(trace_wins, axis=0).transpose([0, 2, 1])

    if ret_roi_stats:
        return xran, trace_wins, [roi_means, roi_stds]
    else:
        return xran, trace_wins


#############################################
def convert_to_binary_cols(df, col, vals, targ_vals):
    """
    convert_to_binary_cols(df, col, vals, targ_vals)

    Returns the input dataframe with the column values converted to categorical
    binary columns. The original column is dropped.

    Required args:
        - df (pd DataFrame): dataframe
        - col (str)        : column name
        - vals (list)      : ordered list of target values
        - targ_vals (list) : ordered list of target value names

    Returns:
        - df (pd DataFrame): dataframe with column values converted to 
                             categorical binary columns
    """

    uniq_vals = df[col].unique().tolist()    
    if not set(uniq_vals).issubset(set(vals)):
        raise ValueError(f'Unexpected values for {col}.')
    
    mapping = dict()
    for val in vals:
        mapping[val] = 0
    for val, targ in zip(vals, targ_vals):    
        col_name = f'{col}${targ}'
        this_mapping = copy.deepcopy(mapping)
        this_mapping[val] = 1
        df[col_name] = df[col].copy().replace(this_mapping)
    df = df.drop(columns=col)

    return df


#############################################
def get_mapping(par, act_vals=None):
    """
    get_mapping(par, act_vals)

    Returns a dictionary to map stimulus values to binary values.

    Required args:
        - par (str): stimulus parameter
        
    Optional args:
        - act_vals (list): actual list of values to double check against 
                           expected possible parameter values. If None, this
                           is not checked.
                           default: None

    Returns:
        - mapping (dict): value (between 0 and 1) for each parameter value
    """

    if par == 'gabk':
        vals = [4, 16]
    elif par == 'bri_size':
        vals = [128, 256]
    elif par == 'bri_dir':
        vals = ['right', 'left']
    elif par == 'line':
        vals = ['L23-Cux2', 'L5-Rbp4']
    elif par == 'plane':
        vals = ['soma', 'dend']
    else:
        gen_util.accepted_values_error('par', par, ['gabk', 'bri_size', 
                                       'bri_dir', 'line', 'plane'])
    
    if act_vals is not None:
        if not set(act_vals).issubset(set(vals)):
            vals_str = ', '.join(list(set(act_vals) - set(vals)))
            raise ValueError(f'Unexpected value(s) for {par}: {vals_str}')

    mapping = dict()
    for i, val in enumerate(vals):
        if val != i:
            mapping[val] = i

    return mapping


#############################################
def add_categ_stim_cols(df):
    """
    add_categ_stim_cols(df)

    Returns dataframe with categorical stimulus information split into binary 
    columns.

    Required args:
        - df (pd DataFrame): stimulus dataframe

    Returns:
        - df (pd DataFrame): stimulus dataframe with categorical stimulus 
                             information split into binary columns
    """

    for col in df.columns:
        if col == 'gab_ori':
            vals = [0, 45, 90, 135, 180, 225]
            df = convert_to_binary_cols(df, col, vals, vals)
        elif col == 'gabfr':
            # Method 1
            # vals = ['grayE', 'grayD', 0, 1, 2, 3, 4]
            # targ_vals = ['grayE', 'grayD', 'A', 'B', 'C', 'D', 'E']

            # Method 2
            vals = ['gray', 0, 1, 2, 3]
            targ_vals = ['gray', 'A', 'B', 'C', 'D']
            df = convert_to_binary_cols(df, col, vals, targ_vals)
        elif col in ['gabk', 'bri_size', 'bri_dir', 'plane', 'line']:
            uniq_vals = df[col].unique().tolist()
            mapping = get_mapping(col, uniq_vals)
            df = df.replace({col: mapping})
        elif col == 'sessid':
            vals = df['sessid'].unique().tolist()
            df = convert_to_binary_cols(df, col, vals, vals)
        else:
            continue

    return df


#############################################
def add_grayscreen_rows_gabors(df):
    """
    add_grayscreen_rows_gabors(df)

    Returns dataframe with grayscreen rows added between Gabor D/E and Gabor A 
    segments.

    Required args:
        - df (pd DataFrame): gabor stimulus dataframe with columns 'gabfr', 
                             'stimSeg', 'start2pfr', 'end2pfr', 'start_stim_fr', 
                             'end_stim_fr', 'surp'

    Returns:
        - df (pd DataFrame): gabor stimulus dataframe with grayscreen rows 
                             added
    """

    if 'gabfr' not in df.columns:
        raise ValueError('Should only be used with dataframes containing '
                         'gabor frame information')

    # add in lines for grayscreen with parameters of previous segment
    # except gabfr and start/end frames          
    pre_seg = df.loc[(df['gabfr'] == 3)].reset_index(drop=True)
    pre_seg = pre_seg.loc[(pre_seg['stimSeg'] < max(pre_seg['stimSeg']))]

    post_seg = df.loc[(df['gabfr'] == 0)].reset_index(drop=True)
    post_seg = post_seg.loc[(post_seg['stimSeg'] > min(post_seg['stimSeg']))]

    gray_seg = pre_seg.copy()

    # Method 1
    # gray_seg['gabfr'] = 'grayD'
    # gray_seg.loc[(gray_seg['gabfr']=='grayD') & 
    #              (gray_seg['surp']==1), 'gabfr'] = 'grayE'

    # Method 2
    gray_seg['gabfr'] = 'gray'

    gray_seg['start2pfr']     = pre_seg['end2pfr'] + 1
    gray_seg['start_stim_fr'] = pre_seg['end_stim_fr'] + 1
    gray_seg['end2pfr']       = post_seg['start2pfr'] - 1
    gray_seg['end_stim_fr']   = post_seg['start_stim_fr'] - 1
    
    df = df.append(gray_seg).sort_values('start2pfr').reset_index(drop=True)

    # Method 1
    # df.loc[(df['gabfr'] == 3) & (df['surp'] == 1), 'gabfr'] = 4
    # df.loc[(df['gabfr'] == 4), 'gab_ori'] += 90
    # df = df.drop(columns='surp')

    # Method 2
    df['surp'] = df['surp'].astype(int)    
    df.loc[~(df['gabfr'].isin([3, 'gray'])) & (df['surp'] == 1), 'surp'] = 0
    
    
    return df

